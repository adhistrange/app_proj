package com.securityresearch.fuzzer.analysis;

import com.securityresearch.fuzzer.core.config.FuzzerConfiguration;
import com.securityresearch.fuzzer.core.execution.TestCaseExecution;
import com.securityresearch.fuzzer.instrumentation.metrics.PerformanceMetrics;
import com.securityresearch.fuzzer.analysis.model.VulnerabilityReport;
import com.securityresearch.fuzzer.analysis.model.VulnerabilityType;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.apache.commons.math3.stat.regression.SimpleRegression;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/**
 * Main vulnerability detector that analyzes performance data to identify
 * algorithmic complexity vulnerabilities and other security issues.
 */
@Component
public class VulnerabilityDetector {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityDetector.class);
    
    private final FuzzerConfiguration configuration;
    private final ConcurrentHashMap<String, List<TestCaseExecution>> executionHistory;
    
    public VulnerabilityDetector(FuzzerConfiguration configuration) {
        this.configuration = configuration;
        this.executionHistory = new ConcurrentHashMap<>();
    }
    
    /**
     * Analyze test case executions for vulnerabilities.
     * 
     * @param testCases List of test case executions
     * @return List of vulnerability reports
     */
    public List<VulnerabilityReport> analyzeTestCases(List<TestCaseExecution> testCases) {
        logger.info("Analyzing {} test cases for vulnerabilities", testCases.size());
        
        List<VulnerabilityReport> reports = new ArrayList<>();
        
        // Group test cases by method (simplified)
        Map<String, List<TestCaseExecution>> testCasesByMethod = testCases.stream()
                .collect(Collectors.groupingBy(tc -> tc.getTestCaseId()));
        
        // Analyze each method
        for (Map.Entry<String, List<TestCaseExecution>> entry : testCasesByMethod.entrySet()) {
            String methodName = entry.getKey();
            List<TestCaseExecution> methodTestCases = entry.getValue();
            
            // Update execution history
            executionHistory.computeIfAbsent(methodName, k -> new ArrayList<>())
                          .addAll(methodTestCases);
            
            // Simple vulnerability detection
            List<VulnerabilityReport> methodReports = detectVulnerabilities(methodTestCases);
            reports.addAll(methodReports);
        }
        
        // Sort reports by severity
        reports.sort((r1, r2) -> r2.getSeverity().compareTo(r1.getSeverity()));
        
        logger.info("Found {} potential vulnerabilities", reports.size());
        return reports;
    }
    
    /**
     * Analyze performance metrics for vulnerabilities.
     * 
     * @param methodId Method identifier
     * @return List of vulnerability reports
     */
    public List<VulnerabilityReport> analyzePerformanceMetrics(String methodId) {
        PerformanceMetrics metrics = PerformanceMetrics.getMetrics(methodId);
        if (metrics == null || metrics.getExecutionCount() == 0) {
            return Collections.emptyList();
        }
        
        List<VulnerabilityReport> reports = new ArrayList<>();
        
        // Check for performance anomalies
        if (metrics.hasPerformanceIssues(
                (long)(configuration.getPerformance().getOutlierThreshold() * 1_000_000), // Convert to nanos
                configuration.getExecution().getMaxMemoryBytes())) {
            
            VulnerabilityReport report = VulnerabilityReport.builder()
                    .methodId(methodId)
                    .vulnerabilityType(VulnerabilityType.PERFORMANCE_ANOMALY)
                    .severity(VulnerabilityReport.Severity.MEDIUM)
                    .description("Performance anomaly detected")
                    .evidence(String.format(
                        "Avg time: %.2f ms, Max time: %.2f ms, Avg memory: %.2f MB, Max memory: %.2f MB",
                        metrics.getAverageExecutionTimeNanos() / 1_000_000.0,
                        metrics.getMaxExecutionTimeNanos() / 1_000_000.0,
                        metrics.getAverageMemoryUsageBytes() / (1024.0 * 1024.0),
                        metrics.getMaxMemoryUsageBytes() / (1024.0 * 1024.0)
                    ))
                    .confidence(calculateConfidence(metrics))
                    .build();
            
            reports.add(report);
        }
        
        return reports;
    }
    
    /**
     * Perform statistical analysis on execution patterns.
     * 
     * @param methodId Method identifier
     * @return Statistical analysis results
     */
    public StatisticalAnalysisResult performStatisticalAnalysis(String methodId) {
        List<TestCaseExecution> executions = executionHistory.get(methodId);
        if (executions == null || executions.size() < 10) {
            return new StatisticalAnalysisResult(methodId, false, "Insufficient data");
        }
        
        // Extract execution times (simplified)
        double[] executionTimes = executions.stream()
                .mapToDouble(tc -> 1.0) // Placeholder - would use actual metrics
                .toArray();
        
        DescriptiveStatistics stats = new DescriptiveStatistics(executionTimes);
        
        // Check for exponential growth patterns
        SimpleRegression regression = new SimpleRegression();
        for (int i = 0; i < executionTimes.length; i++) {
            regression.addData(i, Math.log(executionTimes[i] + 1)); // Log to detect exponential
        }
        
        double rSquared = regression.getRSquare();
        double slope = regression.getSlope();
        
        boolean hasExponentialGrowth = rSquared > 0.8 && slope > 0.1;
        
        return new StatisticalAnalysisResult(
            methodId,
            hasExponentialGrowth,
            String.format("RÂ²=%.3f, slope=%.3f, mean=%.2f ms, std=%.2f ms", 
                         rSquared, slope, stats.getMean(), stats.getStandardDeviation())
        );
    }
    
    /**
     * Calculate confidence level for a vulnerability report.
     * 
     * @param metrics Performance metrics
     * @return Confidence level (0.0 to 1.0)
     */
    private double calculateConfidence(PerformanceMetrics metrics) {
        long executionCount = metrics.getExecutionCount();
        if (executionCount < 5) {
            return 0.3; // Low confidence with few samples
        }
        
        double timeStdDev = metrics.getExecutionTimeStandardDeviation();
        double timeMean = metrics.getAverageExecutionTimeNanos();
        double timeCoeffVar = timeStdDev / timeMean;
        
        double memoryStdDev = metrics.getMemoryUsageStandardDeviation();
        double memoryMean = metrics.getAverageMemoryUsageBytes();
        double memoryCoeffVar = memoryStdDev / memoryMean;
        
        // Higher confidence with more consistent patterns
        double consistencyScore = 1.0 - Math.min(timeCoeffVar, memoryCoeffVar);
        double sampleScore = Math.min(executionCount / 100.0, 1.0);
        
        return Math.min(consistencyScore * 0.7 + sampleScore * 0.3, 1.0);
    }
    
    /**
     * Get execution history for a method.
     * 
     * @param methodId Method identifier
     * @return List of test case executions
     */
    public List<TestCaseExecution> getExecutionHistory(String methodId) {
        return executionHistory.getOrDefault(methodId, Collections.emptyList());
    }
    
    /**
     * Clear execution history.
     */
    public void clearExecutionHistory() {
        executionHistory.clear();
    }
    
    /**
     * Get summary statistics for all analyzed methods.
     * 
     * @return Summary statistics
     */
    public Map<String, Object> getSummaryStatistics() {
        Map<String, Object> summary = new HashMap<>();
        
        summary.put("totalMethods", executionHistory.size());
        summary.put("totalExecutions", executionHistory.values().stream()
                .mapToInt(List::size)
                .sum());
        
        // Performance metrics summary
        String[] methodIds = PerformanceMetrics.getAllMethodIds();
        summary.put("instrumentedMethods", methodIds.length);
        
        if (methodIds.length > 0) {
            double avgExecutionTime = Arrays.stream(methodIds)
                    .mapToDouble(id -> PerformanceMetrics.getMetrics(id).getAverageExecutionTimeNanos())
                    .average()
                    .orElse(0.0);
            summary.put("averageExecutionTimeMs", avgExecutionTime / 1_000_000.0);
        }
        
        return summary;
    }
    
    /**
     * Simple vulnerability detection method.
     * 
     * @param testCases List of test case executions
     * @return List of vulnerability reports
     */
    private List<VulnerabilityReport> detectVulnerabilities(List<TestCaseExecution> testCases) {
        List<VulnerabilityReport> reports = new ArrayList<>();
        
        // Simple detection logic - would be more sophisticated in real implementation
        if (testCases.size() > 10) {
            VulnerabilityReport report = VulnerabilityReport.builder()
                    .methodId("test-method")
                    .vulnerabilityType(VulnerabilityType.PERFORMANCE_ANOMALY)
                    .severity(VulnerabilityReport.Severity.MEDIUM)
                    .description("Multiple test cases detected")
                    .evidence("Found " + testCases.size() + " test cases")
                    .confidence(0.7)
                    .build();
            reports.add(report);
        }
        
        return reports;
    }
    
    /**
     * Result of statistical analysis.
     */
    public static class StatisticalAnalysisResult {
        private final String methodId;
        private final boolean hasExponentialGrowth;
        private final String details;
        
        public StatisticalAnalysisResult(String methodId, boolean hasExponentialGrowth, String details) {
            this.methodId = methodId;
            this.hasExponentialGrowth = hasExponentialGrowth;
            this.details = details;
        }
        
        public String getMethodId() { return methodId; }
        public boolean hasExponentialGrowth() { return hasExponentialGrowth; }
        public String getDetails() { return details; }
    }
} 